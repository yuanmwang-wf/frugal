#
# Autogenerated by Frugal Compiler (2.27.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#



from datetime import timedelta
from threading import Lock

from frugal.exceptions import TApplicationExceptionType
from frugal.exceptions import TTransportExceptionType
from frugal.middleware import Method
from frugal.tornado.processor import FBaseProcessor
from frugal.tornado.processor import FProcessorFunction
from frugal.transport import TMemoryOutputBuffer
from frugal.util.deprecate import deprecated
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType
from thrift.transport.TTransport import TTransportException
from tornado import gen
from tornado.concurrent import Future

import actual_base.python.f_BaseFoo
import actual_base.python.ttypes
import actual_base.python.constants
import validStructs.ttypes
import validStructs.constants
import ValidTypes.ttypes
import ValidTypes.constants
import subdir_include.ttypes
import subdir_include.constants
from .ttypes import *


class Iface(actual_base.python.f_BaseFoo.Iface):
    """
    This is a thrift service. Frugal will generate bindings that include
    a frugal Context for each service call.
    """

    @deprecated
    def Ping(self, ctx):
        """
        Ping the server.
        
        Args:
            ctx: FContext
        
        deprecated: don't use this; use "something else"
        """
        pass

    def blah(self, ctx, num, Str, event):
        """
        Blah the server.
        
        Args:
            ctx: FContext
            num: int (signed 32 bits)
            Str: string
            event: Event
        """
        pass

    def oneWay(self, ctx, id, req):
        """
        oneway methods don't receive a response from the server.
        
        Args:
            ctx: FContext
            id: int (signed 64 bits)
            req: dict of <int (signed 32 bits), string>
        """
        pass

    def bin_method(self, ctx, bin, Str):
        """
        Args:
            ctx: FContext
            bin: binary string
            Str: string
        """
        pass

    def param_modifiers(self, ctx, opt_num, default_num, req_num):
        """
        Args:
            ctx: FContext
            opt_num: int (signed 32 bits)
            default_num: int (signed 32 bits)
            req_num: int (signed 32 bits)
        """
        pass

    def underlying_types_test(self, ctx, list_type, set_type):
        """
        Args:
            ctx: FContext
            list_type: list of int (signed 64 bits)
            set_type: set of int (signed 64 bits)
        """
        pass

    def getThing(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getMyInt(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def use_subdir_struct(self, ctx, a):
        """
        Args:
            ctx: FContext
            a: subdir_include.A
        """
        pass

    def sayHelloWith(self, ctx, newMessage):
        """
        Args:
            ctx: FContext
            newMessage: string
        """
        pass

    def whatDoYouSay(self, ctx, messageArgs):
        """
        Args:
            ctx: FContext
            messageArgs: string
        """
        pass

    def sayAgain(self, ctx, messageResult):
        """
        Args:
            ctx: FContext
            messageResult: string
        """
        pass


class Client(actual_base.python.f_BaseFoo.Client, Iface):

    def __init__(self, provider, middleware=None):
        """
        Create a new Client with an FServiceProvider containing a transport
        and protocol factory.

        Args:
            provider: FServiceProvider
            middleware: ServiceMiddleware or list of ServiceMiddleware
        """
        middleware = middleware or []
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]
        super(Client, self).__init__(provider, middleware=middleware)
        middleware += provider.get_middleware()
        self._methods.update({
            'Ping': Method(self._Ping, middleware),
            'blah': Method(self._blah, middleware),
            'oneWay': Method(self._oneWay, middleware),
            'bin_method': Method(self._bin_method, middleware),
            'param_modifiers': Method(self._param_modifiers, middleware),
            'underlying_types_test': Method(self._underlying_types_test, middleware),
            'getThing': Method(self._getThing, middleware),
            'getMyInt': Method(self._getMyInt, middleware),
            'use_subdir_struct': Method(self._use_subdir_struct, middleware),
            'sayHelloWith': Method(self._sayHelloWith, middleware),
            'whatDoYouSay': Method(self._whatDoYouSay, middleware),
            'sayAgain': Method(self._sayAgain, middleware),
        })

    @deprecated
    def Ping(self, ctx):
        """
        Ping the server.
        
        Args:
            ctx: FContext
        
        deprecated: don't use this; use "something else"
        """
        return self._methods['Ping']([ctx])

    @gen.coroutine
    def _Ping(self, ctx):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('ping', TMessageType.CALL, 0)
        args = Ping_args()
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = yield self._transport.request(ctx, buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = Ping_result()
        result.read(iprot)
        iprot.readMessageEnd()
    def blah(self, ctx, num, Str, event):
        """
        Blah the server.
        
        Args:
            ctx: FContext
            num: int (signed 32 bits)
            Str: string
            event: Event
        """
        return self._methods['blah']([ctx, num, Str, event])

    @gen.coroutine
    def _blah(self, ctx, num, Str, event):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('blah', TMessageType.CALL, 0)
        args = blah_args()
        args.num = num
        args.Str = Str
        args.event = event
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = yield self._transport.request(ctx, buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = blah_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.awe is not None:
            raise result.awe
        if result.api is not None:
            raise result.api
        if result.success is not None:
            raise gen.Return(result.success)
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "blah failed: unknown result")
    def oneWay(self, ctx, id, req):
        """
        oneway methods don't receive a response from the server.
        
        Args:
            ctx: FContext
            id: int (signed 64 bits)
            req: dict of <int (signed 32 bits), string>
        """
        return self._methods['oneWay']([ctx, id, req])

    @gen.coroutine
    def _oneWay(self, ctx, id, req):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('oneWay', TMessageType.CALL, 0)
        args = oneWay_args()
        args.id = id
        args.req = req
        args.write(oprot)
        oprot.writeMessageEnd()
        yield self._transport.oneway(ctx, buffer.getvalue())

    def bin_method(self, ctx, bin, Str):
        """
        Args:
            ctx: FContext
            bin: binary string
            Str: string
        """
        return self._methods['bin_method']([ctx, bin, Str])

    @gen.coroutine
    def _bin_method(self, ctx, bin, Str):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('bin_method', TMessageType.CALL, 0)
        args = bin_method_args()
        args.bin = bin
        args.Str = Str
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = yield self._transport.request(ctx, buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = bin_method_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.api is not None:
            raise result.api
        if result.success is not None:
            raise gen.Return(result.success)
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "bin_method failed: unknown result")
    def param_modifiers(self, ctx, opt_num, default_num, req_num):
        """
        Args:
            ctx: FContext
            opt_num: int (signed 32 bits)
            default_num: int (signed 32 bits)
            req_num: int (signed 32 bits)
        """
        return self._methods['param_modifiers']([ctx, opt_num, default_num, req_num])

    @gen.coroutine
    def _param_modifiers(self, ctx, opt_num, default_num, req_num):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('param_modifiers', TMessageType.CALL, 0)
        args = param_modifiers_args()
        args.opt_num = opt_num
        args.default_num = default_num
        args.req_num = req_num
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = yield self._transport.request(ctx, buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = param_modifiers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            raise gen.Return(result.success)
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "param_modifiers failed: unknown result")
    def underlying_types_test(self, ctx, list_type, set_type):
        """
        Args:
            ctx: FContext
            list_type: list of int (signed 64 bits)
            set_type: set of int (signed 64 bits)
        """
        return self._methods['underlying_types_test']([ctx, list_type, set_type])

    @gen.coroutine
    def _underlying_types_test(self, ctx, list_type, set_type):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('underlying_types_test', TMessageType.CALL, 0)
        args = underlying_types_test_args()
        args.list_type = list_type
        args.set_type = set_type
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = yield self._transport.request(ctx, buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = underlying_types_test_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            raise gen.Return(result.success)
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "underlying_types_test failed: unknown result")
    def getThing(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getThing']([ctx])

    @gen.coroutine
    def _getThing(self, ctx):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('getThing', TMessageType.CALL, 0)
        args = getThing_args()
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = yield self._transport.request(ctx, buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getThing_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            raise gen.Return(result.success)
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getThing failed: unknown result")
    def getMyInt(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getMyInt']([ctx])

    @gen.coroutine
    def _getMyInt(self, ctx):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('getMyInt', TMessageType.CALL, 0)
        args = getMyInt_args()
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = yield self._transport.request(ctx, buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getMyInt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            raise gen.Return(result.success)
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getMyInt failed: unknown result")
    def use_subdir_struct(self, ctx, a):
        """
        Args:
            ctx: FContext
            a: subdir_include.A
        """
        return self._methods['use_subdir_struct']([ctx, a])

    @gen.coroutine
    def _use_subdir_struct(self, ctx, a):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('use_subdir_struct', TMessageType.CALL, 0)
        args = use_subdir_struct_args()
        args.a = a
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = yield self._transport.request(ctx, buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = use_subdir_struct_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            raise gen.Return(result.success)
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "use_subdir_struct failed: unknown result")
    def sayHelloWith(self, ctx, newMessage):
        """
        Args:
            ctx: FContext
            newMessage: string
        """
        return self._methods['sayHelloWith']([ctx, newMessage])

    @gen.coroutine
    def _sayHelloWith(self, ctx, newMessage):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('sayHelloWith', TMessageType.CALL, 0)
        args = sayHelloWith_args()
        args.newMessage = newMessage
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = yield self._transport.request(ctx, buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = sayHelloWith_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            raise gen.Return(result.success)
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "sayHelloWith failed: unknown result")
    def whatDoYouSay(self, ctx, messageArgs):
        """
        Args:
            ctx: FContext
            messageArgs: string
        """
        return self._methods['whatDoYouSay']([ctx, messageArgs])

    @gen.coroutine
    def _whatDoYouSay(self, ctx, messageArgs):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('whatDoYouSay', TMessageType.CALL, 0)
        args = whatDoYouSay_args()
        args.messageArgs = messageArgs
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = yield self._transport.request(ctx, buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = whatDoYouSay_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            raise gen.Return(result.success)
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "whatDoYouSay failed: unknown result")
    def sayAgain(self, ctx, messageResult):
        """
        Args:
            ctx: FContext
            messageResult: string
        """
        return self._methods['sayAgain']([ctx, messageResult])

    @gen.coroutine
    def _sayAgain(self, ctx, messageResult):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('sayAgain', TMessageType.CALL, 0)
        args = sayAgain_args()
        args.messageResult = messageResult
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = yield self._transport.request(ctx, buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = sayAgain_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            raise gen.Return(result.success)
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "sayAgain failed: unknown result")

class Processor(actual_base.python.f_BaseFoo.Processor):

    def __init__(self, handler, middleware=None):
        """
        Create a new Processor.

        Args:
            handler: Iface
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]

        super(Processor, self).__init__(handler, middleware=middleware)
        self.add_to_processor_map('ping', _Ping(Method(handler.Ping, middleware), self.get_write_lock()))
        self.add_to_annotations_map('ping', {'deprecated': "don't use this; use \"something else\""})
        self.add_to_processor_map('blah', _blah(Method(handler.blah, middleware), self.get_write_lock()))
        self.add_to_processor_map('oneWay', _oneWay(Method(handler.oneWay, middleware), self.get_write_lock()))
        self.add_to_processor_map('bin_method', _bin_method(Method(handler.bin_method, middleware), self.get_write_lock()))
        self.add_to_processor_map('param_modifiers', _param_modifiers(Method(handler.param_modifiers, middleware), self.get_write_lock()))
        self.add_to_processor_map('underlying_types_test', _underlying_types_test(Method(handler.underlying_types_test, middleware), self.get_write_lock()))
        self.add_to_processor_map('getThing', _getThing(Method(handler.getThing, middleware), self.get_write_lock()))
        self.add_to_processor_map('getMyInt', _getMyInt(Method(handler.getMyInt, middleware), self.get_write_lock()))
        self.add_to_processor_map('use_subdir_struct', _use_subdir_struct(Method(handler.use_subdir_struct, middleware), self.get_write_lock()))
        self.add_to_processor_map('sayHelloWith', _sayHelloWith(Method(handler.sayHelloWith, middleware), self.get_write_lock()))
        self.add_to_processor_map('whatDoYouSay', _whatDoYouSay(Method(handler.whatDoYouSay, middleware), self.get_write_lock()))
        self.add_to_processor_map('sayAgain', _sayAgain(Method(handler.sayAgain, middleware), self.get_write_lock()))


class _Ping(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_Ping, self).__init__(handler, lock)

    @gen.coroutine
    @deprecated
    def process(self, ctx, iprot, oprot):
        args = Ping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = Ping_result()
        try:
            yield gen.maybe_future(self._handler([ctx]))
        except TApplicationException as ex:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "ping", exception=ex)
                return
        except Exception as e:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "ping", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with (yield self._lock.acquire()):
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('ping', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "ping", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _blah(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_blah, self).__init__(handler, lock)

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = blah_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = blah_result()
        try:
            result.success = yield gen.maybe_future(self._handler([ctx, args.num, args.Str, args.event]))
        except AwesomeException as awe:
            result.awe = awe
        except actual_base.python.ttypes.api_exception as api:
            result.api = api
        except TApplicationException as ex:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "blah", exception=ex)
                return
        except Exception as e:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "blah", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with (yield self._lock.acquire()):
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('blah', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "blah", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _oneWay(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_oneWay, self).__init__(handler, lock)

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = oneWay_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            yield gen.maybe_future(self._handler([ctx, args.id, args.req]))
        except TApplicationException as ex:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "oneWay", exception=ex)
                return
        except Exception as e:
            raise


class _bin_method(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_bin_method, self).__init__(handler, lock)

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = bin_method_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = bin_method_result()
        try:
            result.success = yield gen.maybe_future(self._handler([ctx, args.bin, args.Str]))
        except actual_base.python.ttypes.api_exception as api:
            result.api = api
        except TApplicationException as ex:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "bin_method", exception=ex)
                return
        except Exception as e:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "bin_method", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with (yield self._lock.acquire()):
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('bin_method', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "bin_method", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _param_modifiers(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_param_modifiers, self).__init__(handler, lock)

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = param_modifiers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = param_modifiers_result()
        try:
            result.success = yield gen.maybe_future(self._handler([ctx, args.opt_num, args.default_num, args.req_num]))
        except TApplicationException as ex:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "param_modifiers", exception=ex)
                return
        except Exception as e:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "param_modifiers", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with (yield self._lock.acquire()):
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('param_modifiers', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "param_modifiers", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _underlying_types_test(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_underlying_types_test, self).__init__(handler, lock)

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = underlying_types_test_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = underlying_types_test_result()
        try:
            result.success = yield gen.maybe_future(self._handler([ctx, args.list_type, args.set_type]))
        except TApplicationException as ex:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "underlying_types_test", exception=ex)
                return
        except Exception as e:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "underlying_types_test", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with (yield self._lock.acquire()):
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('underlying_types_test', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "underlying_types_test", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _getThing(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getThing, self).__init__(handler, lock)

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = getThing_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getThing_result()
        try:
            result.success = yield gen.maybe_future(self._handler([ctx]))
        except TApplicationException as ex:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "getThing", exception=ex)
                return
        except Exception as e:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "getThing", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with (yield self._lock.acquire()):
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getThing', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getThing", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _getMyInt(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getMyInt, self).__init__(handler, lock)

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = getMyInt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMyInt_result()
        try:
            result.success = yield gen.maybe_future(self._handler([ctx]))
        except TApplicationException as ex:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "getMyInt", exception=ex)
                return
        except Exception as e:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "getMyInt", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with (yield self._lock.acquire()):
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getMyInt', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getMyInt", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _use_subdir_struct(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_use_subdir_struct, self).__init__(handler, lock)

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = use_subdir_struct_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = use_subdir_struct_result()
        try:
            result.success = yield gen.maybe_future(self._handler([ctx, args.a]))
        except TApplicationException as ex:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "use_subdir_struct", exception=ex)
                return
        except Exception as e:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "use_subdir_struct", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with (yield self._lock.acquire()):
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('use_subdir_struct', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "use_subdir_struct", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _sayHelloWith(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_sayHelloWith, self).__init__(handler, lock)

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = sayHelloWith_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sayHelloWith_result()
        try:
            result.success = yield gen.maybe_future(self._handler([ctx, args.newMessage]))
        except TApplicationException as ex:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "sayHelloWith", exception=ex)
                return
        except Exception as e:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "sayHelloWith", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with (yield self._lock.acquire()):
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('sayHelloWith', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "sayHelloWith", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _whatDoYouSay(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_whatDoYouSay, self).__init__(handler, lock)

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = whatDoYouSay_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = whatDoYouSay_result()
        try:
            result.success = yield gen.maybe_future(self._handler([ctx, args.messageArgs]))
        except TApplicationException as ex:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "whatDoYouSay", exception=ex)
                return
        except Exception as e:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "whatDoYouSay", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with (yield self._lock.acquire()):
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('whatDoYouSay', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "whatDoYouSay", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _sayAgain(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_sayAgain, self).__init__(handler, lock)

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = sayAgain_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = sayAgain_result()
        try:
            result.success = yield gen.maybe_future(self._handler([ctx, args.messageResult]))
        except TApplicationException as ex:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "sayAgain", exception=ex)
                return
        except Exception as e:
            with (yield self._lock.acquire()):
                _write_application_exception(ctx, oprot, "sayAgain", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with (yield self._lock.acquire()):
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('sayAgain', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "sayAgain", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


def _write_application_exception(ctx, oprot, method, ex_code=None, message=None, exception=None):
    if exception is not None:
        x = exception
    else:
        x = TApplicationException(type=ex_code, message=message)
    oprot.write_response_headers(ctx)
    oprot.writeMessageBegin(method, TMessageType.EXCEPTION, 0)
    x.write(oprot)
    oprot.writeMessageEnd()
    oprot.get_transport().flush()
    return x

class Ping_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('Ping_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class Ping_result(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('Ping_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class blah_args(object):
    """
    Attributes:
     - num
     - Str
     - event
    """
    def __init__(self, num=None, Str=None, event=None):
        self.num = num
        self.Str = Str
        self.event = event

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.Str = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.event = Event()
                    self.event.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('blah_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I32, 1)
            oprot.writeI32(self.num)
            oprot.writeFieldEnd()
        if self.Str is not None:
            oprot.writeFieldBegin('Str', TType.STRING, 2)
            oprot.writeString(self.Str)
            oprot.writeFieldEnd()
        if self.event is not None:
            oprot.writeFieldBegin('event', TType.STRUCT, 3)
            self.event.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.num))
        value = (value * 31) ^ hash(make_hashable(self.Str))
        value = (value * 31) ^ hash(make_hashable(self.event))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class blah_result(object):
    """
    Attributes:
     - success
     - awe
     - api
    """
    def __init__(self, success=None, awe=None, api=None):
        self.success = success
        self.awe = awe
        self.api = api

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.awe = AwesomeException()
                    self.awe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.api = actual_base.python.ttypes.api_exception()
                    self.api.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('blah_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.awe is not None:
            oprot.writeFieldBegin('awe', TType.STRUCT, 1)
            self.awe.write(oprot)
            oprot.writeFieldEnd()
        if self.api is not None:
            oprot.writeFieldBegin('api', TType.STRUCT, 2)
            self.api.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.awe))
        value = (value * 31) ^ hash(make_hashable(self.api))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class oneWay_args(object):
    """
    Attributes:
     - id
     - req
    """
    def __init__(self, id=None, req=None):
        self.id = id
        self.req = req

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.req = {}
                    (_, _, elem45) = iprot.readMapBegin()
                    for _ in range(elem45):
                        elem47 = iprot.readI32()
                        elem46 = iprot.readString()
                        self.req[elem47] = elem46
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('oneWay_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.MAP, 2)
            oprot.writeMapBegin(TType.I32, TType.STRING, len(self.req))
            for elem49, elem48 in self.req.items():
                oprot.writeI32(elem49)
                oprot.writeString(elem48)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.id))
        value = (value * 31) ^ hash(make_hashable(self.req))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class bin_method_args(object):
    """
    Attributes:
     - bin
     - Str
    """
    def __init__(self, bin=None, Str=None):
        self.bin = bin
        self.Str = Str

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.bin = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.Str = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('bin_method_args')
        if self.bin is not None:
            oprot.writeFieldBegin('bin', TType.STRING, 1)
            oprot.writeBinary(self.bin)
            oprot.writeFieldEnd()
        if self.Str is not None:
            oprot.writeFieldBegin('Str', TType.STRING, 2)
            oprot.writeString(self.Str)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.bin))
        value = (value * 31) ^ hash(make_hashable(self.Str))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class bin_method_result(object):
    """
    Attributes:
     - success
     - api
    """
    def __init__(self, success=None, api=None):
        self.success = success
        self.api = api

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.api = actual_base.python.ttypes.api_exception()
                    self.api.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('bin_method_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.api is not None:
            oprot.writeFieldBegin('api', TType.STRUCT, 1)
            self.api.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.api))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class param_modifiers_args(object):
    """
    Attributes:
     - opt_num
     - default_num
     - req_num
    """
    def __init__(self, opt_num=None, default_num=None, req_num=None):
        self.opt_num = opt_num
        self.default_num = default_num
        self.req_num = req_num

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.opt_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.default_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.req_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('param_modifiers_args')
        if self.opt_num is not None:
            oprot.writeFieldBegin('opt_num', TType.I32, 1)
            oprot.writeI32(self.opt_num)
            oprot.writeFieldEnd()
        if self.default_num is not None:
            oprot.writeFieldBegin('default_num', TType.I32, 2)
            oprot.writeI32(self.default_num)
            oprot.writeFieldEnd()
        if self.req_num is not None:
            oprot.writeFieldBegin('req_num', TType.I32, 3)
            oprot.writeI32(self.req_num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.req_num is None:
            raise TProtocol.TProtocolException(type=TProtocol.TProtocolException.INVALID_DATA, message='Required field \'req_num\' is not present in struct \'param_modifiers_args\'')
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.opt_num))
        value = (value * 31) ^ hash(make_hashable(self.default_num))
        value = (value * 31) ^ hash(make_hashable(self.req_num))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class param_modifiers_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('param_modifiers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class underlying_types_test_args(object):
    """
    Attributes:
     - list_type
     - set_type
    """
    def __init__(self, list_type=None, set_type=None):
        self.list_type = list_type
        self.set_type = set_type

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.list_type = []
                    (_, elem50) = iprot.readListBegin()
                    for _ in range(elem50):
                        elem51 = iprot.readI64()
                        self.list_type.append(elem51)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.set_type = set()
                    (_, elem52) = iprot.readSetBegin()
                    for _ in range(elem52):
                        elem53 = iprot.readI64()
                        self.set_type.add(elem53)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('underlying_types_test_args')
        if self.list_type is not None:
            oprot.writeFieldBegin('list_type', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.list_type))
            for elem54 in self.list_type:
                oprot.writeI64(elem54)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.set_type is not None:
            oprot.writeFieldBegin('set_type', TType.SET, 2)
            oprot.writeSetBegin(TType.I64, len(self.set_type))
            for elem55 in self.set_type:
                oprot.writeI64(elem55)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.list_type))
        value = (value * 31) ^ hash(make_hashable(self.set_type))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class underlying_types_test_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem56) = iprot.readListBegin()
                    for _ in range(elem56):
                        elem57 = iprot.readI64()
                        self.success.append(elem57)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('underlying_types_test_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I64, len(self.success))
            for elem58 in self.success:
                oprot.writeI64(elem58)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getThing_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getThing_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getThing_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = validStructs.ttypes.Thing()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getThing_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMyInt_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMyInt_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMyInt_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMyInt_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class use_subdir_struct_args(object):
    """
    Attributes:
     - a
    """
    def __init__(self, a=None):
        self.a = a

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.a = subdir_include.ttypes.A()
                    self.a.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('use_subdir_struct_args')
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.STRUCT, 1)
            self.a.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.a))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class use_subdir_struct_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = subdir_include.ttypes.A()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('use_subdir_struct_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sayHelloWith_args(object):
    """
    Attributes:
     - newMessage
    """
    def __init__(self, newMessage=None):
        self.newMessage = newMessage

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.newMessage = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sayHelloWith_args')
        if self.newMessage is not None:
            oprot.writeFieldBegin('newMessage', TType.STRING, 1)
            oprot.writeString(self.newMessage)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.newMessage))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sayHelloWith_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sayHelloWith_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class whatDoYouSay_args(object):
    """
    Attributes:
     - messageArgs
    """
    def __init__(self, messageArgs=None):
        self.messageArgs = messageArgs

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.messageArgs = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('whatDoYouSay_args')
        if self.messageArgs is not None:
            oprot.writeFieldBegin('messageArgs', TType.STRING, 1)
            oprot.writeString(self.messageArgs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.messageArgs))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class whatDoYouSay_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('whatDoYouSay_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sayAgain_args(object):
    """
    Attributes:
     - messageResult
    """
    def __init__(self, messageResult=None):
        self.messageResult = messageResult

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.messageResult = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sayAgain_args')
        if self.messageResult is not None:
            oprot.writeFieldBegin('messageResult', TType.STRING, 1)
            oprot.writeString(self.messageResult)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.messageResult))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class sayAgain_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('sayAgain_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

